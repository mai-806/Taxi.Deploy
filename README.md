Описание проекта:

- | [1. Архитектура приложения](#step1) | 
- | [2. Связи Frontend](#step2) | 
- | [3. Связи Backend ](#step3) |
- | [4. Связи Graph](#step4) |
- | [5. Связи Metrics](#step5) |
- | [6. Комбинирование сервисов в Compose](#step6) |

***
<a name="step1"></a> 
# 1. Архитектура приложения


![Untitled-2023-04-21-1411](https://github.com/mai-806/fund-wiki/assets/113284506/9e5aaaba-e6f8-4ec3-8cc3-bd3a76388902)



```
____________________________
├── Frontend               |   # Micro-service configuration files located in repository
│   ├── Authentication  - `&1`|          
│	├── Redis - `**`       |    
│   └── User Interface  - `&2`|   # `&X` is common network 
|                          |   # `**` is isolated network
|                          |   
|                          |
├── Backend                |   # each isolated element is a new one network   
│   ├── Kafka - `&3`       |                                   
│   ├── MongoDB - `**`     |                               
│   ├── API Gateway        |                                      
|   ├── Authorisation - `&4`|                                     
|   └── PostgreSQL - `&5`  |                      
|                          |   # `%%` is manual metrics collection
|                          |   # `%%` is `scripted` or `pushgateway` metrics collection
├── Graph                  |   # `^^` is redis-based metrics collection
│   ├──  Graph   - `&6`    |
│   ├──  All algos   - `&7`|                             
│   ├\\\\ PostgreSQL - `**`|   # `\\\` is a replaced element                 
│	└\\\\ Redis - `**`     |
|        filedb.txt        |   # `.txt` is unsecure storage
|                          |
|                          |
├── Metrics                |
│   ├── Prometheus `&4`    |
|   ├── Grafana `&4`       |
|	└── ClickHouse `**`    |
|                          |
└── README.md              | 
```

<a name="step2"></a>
# ***2. Frontend***

## AJAX - технология асинхронного взаимодействия 
Frontend приложение использует AJAX для отправки запросов к API-шлюзу для взаимодействия микросервисов.

Технология AJAX обеспечивает асинхронное взаимодействие, позволяя клиенту отправлять запросы и получать ответы от сервера, не требуя полной перезагрузки страницы и не дожидаясь ответа от Backend, что улучшает пользовательский опыт.

Это особенно выручает при длительных бизнес-процессах или при медленном интернет соединении, что актуально в случае с такси.

## Nginx - балансировщик нагрузки

Сервер Nginx работает как балансировщик нагрузки.
Nginx получает AJAX-запросы от фронтенда и направляет их на API-шлюз к Backend.
Таким образом повышается производительность внутренних взаимодействий микросервисов.

## API Gateway - центральный узел маршрутизации

Шлюз API служит точкой входа для запросов фронтенда и выступает в качестве центрального узла маршрутизации. Он выполняет трансляцию протоколов, позволяя приложениям использовать единый протокол http.

Явное разделение балансировщика Nginx и API-шлюза позволяет балансировщику нагрузки эффективнее распределять запросы между несколькими экземплярами API-шлюза, каждый из которых работает отдельно, что дополнительно распределяет нагрузку между внутренними сервисами.

## Аутентификация и Redis 

На уровне взаимодействия с серверами БД Redis проходит аутентификация (не путать с авторизацией!), а также связь с сервисом алгоритмов (картой) посредством регуляции API-запросов. Вторым пунктом в нашем проекте в виду технических особенностей решили пренебречь, поэтому остановимся на Frontend части. 

После успешной аутентификации пользовательские сессии и куки кэшируются в БД Redis.
Это обеспечивает высокую скорость загрузки веб-страницы по ряду причин:
1. Отсутсвует необходимость проходить цикл повторной аутентификации и авторизации (которая при отсутствии кэширования сессий продлится вплоть до Backend части, где хранится база с данными пользователей), посколько Redis который хранит эти данные вблизи с Frontend, 
2. Redis за счёт быстрой кэш-памяти (как мы знаем из курса архитектур компьютера) улучшает пользовательский опыт за счёт ускорения процесса входа в приложение. 

Редис - это хранилище структур данных.
Как правило это данные в JSON формате.

Подаются данные тоже в JSON.

Удобно использовать структуру данных ***отсортированное множество***.
Хеши – хороший вариант, потому что они идеально подходят для представления объектов. Используя хеш, можно быстро отыскать и получить значение структуры по ее ключу.

***
<a name="step3"></a>
# ***3. Backend***

## Авторизация

Процесс авторизации заключается в определении того, имеет ли пользователь, **прошедший аутентификацию** (взаимодействуя с Frontend частью), необходимые разрешения для доступа к определенным ресурсам приложения или выполнения определенных действий с ними.

Фронтенд выполняет аутентификацию пользователя и перехватывает его ввод, а бэкенд проверяет учетные данные и проверку авторизации. 

Затем фронтенд реагирует на статус авторизации, полученный от бэкенда, и соответствующим образом обновляет пользовательский интерфейс.

## Kafka

Kafka - *брокер сообщений* - это система-посредник между микросервисами, позволяющая им общаться и обмениваться данными асинхронно. 

По аналогии с почтовым отделением, сообщение попадает в очередь, ожидая обработки и доставки. Kafka направляет сообщение по назначению нужному сервису. 
При этом во время отправления не так важно, доступен ли получатель - сервис - в конкретную секунду. Аналогично и в нашей системе приложения общаются, не зная точные данные друг о друге. А выполнив отправку сообщения асинхронно, сервисы продолжат выполнение своих задач. 


## MongoDB

MongoDB обычно используется там, где требуется работа с плохоструктурированными данными. Например, с **профилями пользователей клиентов**, где может содержаться разное число информации. Получается, это нереляционная база данных. Она не опирается на таблицы и строки. 

Вместо этого она хранит данные в гибких, самоописательных *JSON-подобных документах*, называемых BSON (Binary JSON), которые могут иметь различную структуру.

***
<a name="step4"></a>
# ***4. Algos***

> можно не упарываться в описание.
> это же бизнес логика. 
> здесь мне важны лишь связи, и почему именно так.
> а ещё я указываю рабочую сеть, которой всё связано.

Сюда входят такие алгоритмы, как:
- заполнение графа свойствами ребра
- считывание координат
- геолокация - работает на основе API.
- поиск нод/водителя
- течение маршрута
- ценообразование
- обновление карты

Поскольку не все алгоритмы работают посредством API, а на основе файла с координатами,  сервисы необходимо подключать в определенном порядке. Этот процесс регулируется посредством настройки конфигурационных файлов и описан в пункте 6.

Геолокация работает по схеме донор-рецепиент: пользователь во Frontend выбирает начальную и конечную точки пути, а те передаются от Web-интерфейса к внутренней части.

Пусть геолокация определена и у нас есть 2 точки.
Цена будет уходить на Frontend в динамическом режиме вместе с оставшимся временем и маршрутом. Сервис upd_coordinates перенаправляет запрос в кафку, и тот идет на Frontend, где и отрисовывается карта.
Алгоритм поиска ближайшего водителя и ближайшей ноды для движения мудро реализован в рамках одного решения, обеспечивая выполнение обоих задач. 

Поскольку у нас нет своего API, которое определяет местоположение, а также присутствует свой особый графовый алгоритмы, мы будем заполнять всё, исходя из того, как реализовано заполнение графа точками Москвы. 

При регуляции очередности запуска мы позволяем графу включиться в работу первым делом, заполняя его из самописной базы данных на файлах, подготовленной заранее
(наш "Redis", к сожалению, вышел из строя).

## PostgreSQL

Этот экземпляр базы данных был заменён файловым аналогом.
Данное решение хоть и рабочее, но имеет ряд недостатков.
В частности, информация из базы доступна за линейное время: данные считываются покомпоненто. Кроме того, она не защищена паролем, а также не поддерживает обработку http-запросов, что в целом нарушает концепцию микросервисной разработки.

## Redis

Был заменён базой данных на файлах. 
Помимо перечисленных недостатков мы получаем значительное снижение в скорости доступа к координатам города Москвы из-за того, что игнорируем преимущества кэша.

***

При настройке сетевых политик в конфигурационных файлах алгоритмов необходимо будет учитывать, что сервисы алгоритмов будут подключаться покомпонентно, а графовый алгоритм подключится отдельно и в первую очередь, то есть в свою сеть. Остальные алгоритмы будут работать вместе, так как не являются самостоятельными единицами в нашем случае (при моделировании ситуации отключения сервисов данное утверждение подтвердится).

Модель местоположения в наших алгоритмах представлена не в виде документов JSON, а в числовых эквивалентах, хранящихся в файлах (мы пожертвовали быстротой работы во благо работоспособности).
***
<a name="step5"></a>
# ***5. Metrics***

### В общем о мониторинге

Взаимодействия между внутренними сервисами осуществляются посредством REST или обмена сообщениями. Метрики должны сохраняться в базе данных и быть доступными для запросов.

Приложения дают доступ к своим метрикам через конечную точку HTTP, а Prometheus извлекает их через регулярные интервалы времени и анализирует их..

Для служб, в которых нет возможности организовать конечную точку HTTP для чтения метрик, Prometheus предлагает Pushgateway – промежуточную службу, куда другие службы могут самостоятельно отправлять свои данные.

# Prometheus

## 1. Сбор метрик поточных приложений.
В нашем случае это сервисы *аутентификации* (***frontend***) и *алгоритм построения графа* 
(при реализации заполнения графа через `Redis`, а не через файл). 

Аутентификация - микросервис, регулируемый сессиями.
Он получает сессии из потока Redis, поэтому нет необходимости настраивать конечную точку HTTP для сбора метрик.

## 2. Сбор метрик через конечную точку.
Данный вариант мы отставим. Он неоптимален.
Этот метод требует обновления всей существующей кодовой базы изнутри, поскольку включает в себя добавление новых функций. 

## 3. Скриптовый сбор метрик (вручную).
Звучит более привлекательно, чем вариант 2.
Позволяет использовать любой удобный аналитику скриптовый язык для сбора и дальнейшего анализа метрик с микросервиса.

## 4. Сбор метрик через pushgateway.

Чтобы включить мониторинг с помощью Prometheus, можно добавить HTTP-сервер в службу только для этой цели или задействовать службу Pushgateway.

Для нас важно знать, насколько быстро обрабатываются полученные сообщения. Поэтому каждый раз, когда микросервис получает и обрабатывает очередное событие, он должен отправлять соответствующую информацию в Prometheus с помощью сервиса Pushgateway.

## 5. Настройка анализа метрик в Prometheus

Чтобы Prometheus мог выполнять анализ данных, получаемых из конечной точки, необходимо определить конфигурацию задания. Конфигурации заданий для Prometheus описываются в формате YAML.

***
# Добавление Prometheus в сеть Compose

Поскольку мы решили добавить поддержку мониторинга во все наши службы, мы должны добавить настройки Prometheus в файл Compose для сбора и анализа метрик из всех наших служб.

Так как Prometheus взаимодействует со всеми существующими службами, эти взаимодействия не должны выполняться из внешней сети.
Мы должны добавить сеть, с которой Prometheus сможет работать. 
Назовем ее monitoring-network.

Затем создадим конфигурационный файл с настройками Prometheus под все службы нашего приложения. 

***
<a name="step6"></a>
# 6. Комбинирование сервисов в Compose 


Разделение конфигураций compose даёт нам большую модульность, а значит и гибкость в разработке. При этом можем запускать локально целые приложения, используя фиктивные службы для имитации http запросов, такие как **Hoverfly**.

К базовым компонентам, используемым всеми службами и необходимым для запуска приложения, относятся сети и база данных, и их можно сгруппировать в файл Compose.

В нашем приложении также есть определенные службы, описание которых можно поместить в отдельные файлы Compose: 

- Служба **авторизации** может работать автономно, так как **имеет свою базу данных**.
- Prometheus тоже может работать отдельно, потому что не имеет прямого отношения к цели нашего приложения. Однако он необходим для оценки работоспособности приложения.
- Алгоритмические службы комбинируются по принципу, описанному в пункте 4. 

Основа для **taxi-app** будет включать описание сетей и базы данных Redis. 
Описания сетей Docker имеют большое значение, потому что образуют основу для взаимодействий внутри приложения. 

База данных PostgreSQL, в которой хранятся авторизационные данные пользователей, тоже важна, потому что все наши службы так или иначе зависят от процесса авторизации. 
Поэтому в корне нашего проекта создадим файл base-compose.yaml.

Объединяя различные файлы Compose, мы получим разные окружения, служащие определенным целям, например для локального тестирования.

- Если сеть не указана явно в файле compose, обе службы используют сеть по умолчанию;
- находясь в одной сети, они могут обращаться друг к другу по именам служб;
- все необходимые переменные окружения определяются в разделе environment.
